#pragma kernel CSMain
static const int threadGroupSize = 128;

struct Boid
{
    float3 position;
    float3 moveVector;
    
    float3 avgPosition;
    float3 avgMoveVector;
    float3 avgNeighbourAvoidanceVector;
    float3 avgPredatorAvoidanceVector;
};

RWStructuredBuffer<Boid> boids;
int totalNumberOfBoids;
float viewDistance;
float avoidanceDistance;

int totalNumberOfPredators;
float3 predatorPositions[10];

[numthreads(threadGroupSize,1,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    int currentBoidIndex = id.x;

    boids[currentBoidIndex].avgPosition = 0;
    boids[currentBoidIndex].avgMoveVector = 0;
    boids[currentBoidIndex].avgNeighbourAvoidanceVector = 0;

    int numNeighbours = 0;
    int numNeighboursToAvoid = 0;
    int numOfPredators = 0;

    for (int potentialNeighbourIndex = 0; potentialNeighbourIndex < totalNumberOfBoids; potentialNeighbourIndex++)
    {
        if (currentBoidIndex != potentialNeighbourIndex)
        {
            Boid potentialNeighbour = boids[potentialNeighbourIndex];

            float3 displacementVectorToNeighbour = potentialNeighbour.position - boids[currentBoidIndex].position;
            

            float distanceToNeighbour = sqrt(
                displacementVectorToNeighbour.x * displacementVectorToNeighbour.x +
                displacementVectorToNeighbour.y * displacementVectorToNeighbour.y +
                displacementVectorToNeighbour.z * displacementVectorToNeighbour.z);

            if (distanceToNeighbour < viewDistance && distanceToNeighbour > 0)
            {
                numNeighbours += 1;
                boids[currentBoidIndex].avgPosition += potentialNeighbour.position;
                boids[currentBoidIndex].avgMoveVector += potentialNeighbour.moveVector;

                if (distanceToNeighbour < avoidanceDistance)
                {
                    numNeighboursToAvoid += 1;
                    boids[currentBoidIndex].avgNeighbourAvoidanceVector += - (displacementVectorToNeighbour * (viewDistance / distanceToNeighbour));
                }
            }
        }
    }
 
    if (numNeighbours > 0)
    {
        boids[currentBoidIndex].avgMoveVector /= numNeighbours;
        boids[currentBoidIndex].avgPosition /= numNeighbours;
    }
    
    if (numNeighboursToAvoid > 0)
    {
        boids[currentBoidIndex].avgNeighbourAvoidanceVector /= numNeighboursToAvoid;
    }

    for (int potentialPredatorIndex = 0; potentialPredatorIndex < totalNumberOfPredators; potentialPredatorIndex++)
    {
        float3 potentialPredator = predatorPositions[potentialPredatorIndex];
        
        float3 displacementVectorToPredator = boids[currentBoidIndex].position - potentialPredator;

        float distanceToPredator = sqrt(
            displacementVectorToPredator.x * displacementVectorToPredator.x +
            displacementVectorToPredator.y * displacementVectorToPredator.y +
            displacementVectorToPredator.z * displacementVectorToPredator.z);

        if (distanceToPredator < viewDistance)
        {
            numOfPredators += 1;
            boids[currentBoidIndex].avgPredatorAvoidanceVector += displacementVectorToPredator * (viewDistance / distanceToPredator);
        }
    }

    if(numOfPredators > 0)
    {
       boids[currentBoidIndex].avgPredatorAvoidanceVector /= numOfPredators;
    }
}
